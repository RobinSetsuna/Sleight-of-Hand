  {
        return tile.gridPosition;
    }

    /// <summary>
    /// Get the world position from a grid position
    /// </summary>
    /// <param name="x"> The x value of the grid position to concern </param>
    /// <param name="y"> The y value of the grid position to concern </param>
    /// <returns> A Vector3 struct representing the world position </returns>
    public Vector3 GetWorldPosition(int x, int y)
    {
        return new Vector3((x * 2 + 1) * tileSize, 0, (y * 2 + 1) * tileSize);
    }

    /// <summary>
    /// Get the world position from a grid position
    /// </summary>
    /// <param name="gridPosition"> The grid position to concern </param>
    /// <returns> A Vector3 struct representing the world position </returns>
    public Vector3 GetWorldPosition(Vector2Int gridPosition)
    {
        return GetWorldPosition(gridPosition.x, gridPosition.y);
    }

    /// <summary>
    /// Get the world position of the tile
    /// </summary>
    /// <param name="tile"> The tile to concern </param>
    /// <returns> A Vector3 struct representing the world position </returns>
    public Vector3 GetWorldPosition(Tile tile)
    {
        return GetWorldPosition(tile.gridPosition);
    }

    /// <summary>
    /// Evalueate whether two tiles are considered to be adjacent
    /// </summary>
    /// <param name="A"> The first tile to concern </param>
    /// <param name="B"> The second tile to concern </param>
    /// <returns> A boolean indicating the result of evaluation </returns>
    public bool IsAdjacent(Tile A, Tile B)
    {
        return MathUtility.ManhattanDistance(A.x, A.y, B.x, B.y) == 1;
    }

    /// <summary>
    /// Evaluate whether the grid position is accessible
    /// </summary>
    /// <param name="x"> The x value of the grid position to concern </param>
    /// <param name="y"> The y value of the grid position to concern </param>
    /// <returns> A boolean indicating the result of evaluation </returns>
    public bool IsAccessible(int x, int y)
    {
        return grid[x, y].walkable;
    }

    public bool IsWalkable(int x, int y)
    {
        return grid[x, y].walkable;
    }
    
    public bool HasUnitOn(int x, int y)
    {
        return units[x, y]!=null;
    }

    /// <summary>
    /// Get all accessible positions surrounding a given grid position
    /// </summary>
    /// <param name="x"> The x value of the grid position to concern </param>
    /// <param name="y"> The y value of the grid position to concern </param>
    /// <returns> A List of Vector2Int containing all grid positions </returns>
    public List<Vector2Int> GetAdjacentGridPositions(int x, int y)
    {
        List<Vector2Int> list = new List<Vector2Int>();

        if (x + 1 < Length && grid[x + 1, y])
            list.Add(new Vector2Int(x + 1, y));

        if (x - 1 >= 0 && grid[x - 1, y])
            list.Add(new Vector2Int(x - 1, y));

        if (y + 1 < Width && grid[x, y + 1])
            list.Add(new Vector2Int(x, y + 1));

        if (y - 1 >= 0 && grid[x, y - 1])
            list.Add(new Vector2Int(x, y - 1));

        return list;
    }

    /// <summary>
    /// generated grid map
    /// map_size : the number of cube in row and column
    /// node_radius: the cube radius
    /// parameter: None
    /// </summary>
    public void GenerateMap(LevelManager.LevelData levelData)
    {
        if (!root)
            root = transform.Find("GridRoot");

        if (!root)
        {
            root = new GameObject("GridRoot").transform;
            root.parent = transform;
        }

        // Extract data from levelData
        if (levelData != null)
            mapSize = new Vector2Int(levelData.width, Mathf.CeilToInt(levelData.tiles.Length / levelData.width));

        // new grid with size [mapSize.x,mapSize.y]
        grid = new Tile[mapSize.x, mapSize.y];
        units = new Unit[mapSize.x, mapSize.y];

        int numExistedTiles = root.childCount;

        for (int x = 0; x < mapSize.x; x ++)
            for (int y = 0; y < mapSize.y; y ++)
            {
                int i = x + y * Length;
                int tileType = levelData.tiles[i];
                // parse position for tile
                // Vector3 tilePosition = new Vector3(-mapSize.x/2 +nodeRadius + x + transform.position.x, 2, -mapSize.y/2 + nodeRadius + y + transform.position.z);
                Vector3 tilePosition = GetWorldPosition(x, y);

                Transform tileTransform = i < numExistedTiles ? root.GetChild(i) : Instantiate(tilePrefab, tilePosition, Quaternion.Euler(Vector3.right * 90), root);

                // initiate outline
                tileTransform.localScale = Vector3.one * (1 - outlinePercent);

                // set tile value
                Tile tile = tileTransform.GetComponent<Tile>();
                tile.walkable = tileType == 0;
                tile.gridPosition = new Vector2Int(x, y);
                
                // insertion
                grid[x,y] = tile;
                Vector3 envTilePosition = tilePosition;
                envTilePosition.y = -0.55f;
                if(tileType < 0 )
                {
                    // tileType < 0, road tile add
                    Quaternion roadTileRotation = Quaternion.Euler(0,0, 0);
                    Instantiate(roadTilePrefabs[-tileType-1], envTilePosition, roadTileRotation, environmentHolder);
                }
                else
                {
                    Quaternion envTileRotation = Quaternion.Euler(0, Random.Range(0, 3) * 90f, 0);
                    int envTileIndex = Random.Range(0, environmentTilePrefabs.Length);
                    GameObject envTilePrefab = environmentTilePrefabs[envTileIndex];
                    Instantiate(envTilePrefab, envTilePosition, envTileRotation, environmentHolder);
                    if (tileType != 0&& tileType>0)
                    {
                        Quaternion wallRotation = Quaternion.Euler(0, Random.Range(0, 3) * 90f, 0);
                        Instantiate(wallPrefabs[tileType - 1], tilePosition, wallRotation, environmentHolder);
                    }
                }
                #region ORIGINAL_SWITCH_STATE
//                switch (tileType)
                   //                {
                   //                    case 1:
                   //                        Quaternion wallRotation = Quaternion.Euler(0, (float)UnityEngine.Random.Range(0, 3) * 90f, 0);
                   //                        int wallTileIndex = UnityEngine.Random.Range(0, wallPrefabs.Length);
                   //                        Instantiate(wallPrefabs[wallTileIndex], tilePosition, wallRotation, environmentHolder);
                   //                        goto case 0;
                   //
                   //                    case 0:
                   //                        Vector3 envTilePosition = tilePosition;
                   //                        envTilePosition.y = -0.55f;
                   //                        Quaternion envTileRotation = Quaternion.Euler(0, (float)UnityEngine.Random.Range(0, 3) * 90f, 0);
                   //                        int envTileIndex = UnityEngine.Random.Range(0, environmentTilePrefabs.Length);
                   //                        GameObject envTilePrefab = environmentTilePrefabs[envTileIndex];
                   //                        Instantiate(envTilePrefab, envTilePosition, envTileRotation, environmentHolder);
                   //                        break;
                   //                }
                #endregion
            }
    }

    /// <summary>
    /// Initialize the manager by starting to listen to important events
    /// </summary>
    public void Initialize()
    {
        PlayerController playerController = LevelManager.Instance.playerController;

        playerController.onPathUpdate.AddListener(HandlePathChange);
        playerController.onCurrentPlayerStateChange.AddListener(HandleCurrentPlayerStateChange);

        playerController.onCardToUseUpdate.AddListener(HandleCardToUseChange);
    }

    //public void wipeTiles()
    //{
    //    if (numHighlightedTiles > 0)
    //    {
    //        numHighlightedTiles = 0;
    //        foreach (Tile tile in grid)
    //        {
    //            //reset all tiles
    //            tile.Wipe();
    //        }
    //    }
    //}

    /// <summary>
    /// High light the tile with a given color
    /// </summary>
    /// <param name="tile"> The tile to highlight </param>
    /// <param name="color"> The color to highlight with </param>
    public void Highlight(Tile tile, Tile.HighlightColor color, bool isAdditive = true)
    {
        Highlight(tile, 0, 0, int.MinValue, color, isAdditive);
    }

    /// <summary>
    /// High light tiles within a certain range of a central tile with a given color
    /// </summary>
    /// <param name="center"> The central tile to concern </param>
    /// <param name="range"> The range to concern </param>
    /// <param name="color"> The color to highlight with </param>
    /// <param name="skipUnmasked"> [optional] </param>
    public void Highlight(Tile center, int range, Tile.HighlightColor color, bool isAdditive = true, bool skipUnmasked = false)
    {
        Highlight(center, 0, range, int.MinValue, color, isAdditive, skipUnmasked);
    }

    /// <summary>
    /// High light tiles filtered by a certain mask within a certain range of a central tile with a given color
    /// </summary>
    /// <param name="center"> The central tile to concern </param>
    /// <param name="range"> The range to concern </param>
    /// <param name="mask"> The mask for filtering </param>
    /// <param name="color"> The color to highlight with </param>
    /// <param name="skipUnmasked"> [optional] </param>
    public void Highlight(Tile center, int range, int mask, Tile.HighlightColor color, bool isAdditive = true, bool skipUnmasked = false)
    {
        Highlight(center, 0, range, mask, color, isAdditive, skipUnmasked);
    }

    /// <summary>
    /// High light tiles filtered by a certain mask within a certain interval of distance to a central tile with a given color
    /// </summary>
    /// <param name="center"> The central tile to concern </param>
    /// <param name="lower"> The lower boundary of the distance </param>
    /// <param name="upper"> The higher boundary of the distance </param>
    /// <param name="mask"> The mask for filtering </param>
    /// <param name="color"> The color to highlight with </param>
    /// <param name="skipUnmasked"> [optional] </param>
    public void Highlight(Tile center, int lower, int upper, int mask, Tile.HighlightColor color, bool isAdditive = true, bool skipUnmasked = false)
    {
        bool[,] isVisited = new bool[Length, Width];

        Queue<KeyValuePair<Tile, int>> q = new Queue<KeyValuePair<Tile, int>>();

        q.Enqueue(new KeyValuePair<Tile, int>(center, 0));

        while (q.Count > 0)
        {
            KeyValuePair<Tile, int> p